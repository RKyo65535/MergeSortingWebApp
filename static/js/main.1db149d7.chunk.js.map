{"version":3,"sources":["components/AddItemButton.tsx","components/InputZone.tsx","components/GotoSortButton.tsx","components/MergeSortSelect.tsx","feature/mergeSort/mergeSort.ts","components/ResultText.tsx","sandbox/message.ts","App.tsx","index.tsx"],"names":["AddItemButton","props","type","className","onClick","pushEvent","InputZone","useState","Math","floor","random","exCount","id","autoComplete","placeholder","str","i","returnEx","onChange","event","manageItem","name","target","value","deleteMyself","GotoSortButton","MergeSortSelect","leftAction","leftItem","rightAction","rightItem","mergeSort","state","action","m_mergedItemList","mergedItemList","m_tempItemList","tempItemList","m_currentLeft","currentLeft","m_currentRight","currentRight","m_currentLeftEndPoint","currentLeftEndPoint","m_currentRightEndPoint","currentRightEndPoint","m_currentMergeCount","currentMergeCount","length","padAllRight","updateSortPoint","padAllLeft","initialize","returnParam","updateAction","pow","ResultText","ranking","itemName","message","console","group","warn","log","groupEnd","App","useEffect","phase","setPhase","defaultItems","nanoid","currentItemList","setCurrentItemList","initialState","useReducer","mergeState","dispatchMergeState","deleteItem","key","remainingItems","filter","item","chackMergeCondition","list","itemLength","window","scrollBy","currentShowItemList","beforeMergeSortElement","map","newItem","tempList","initMergeSort","mergeSortZone","resultZone","sortResult","oneResult","ReactDOM","render","document","getElementById"],"mappings":"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","file":"static/js/main.1db149d7.chunk.js","sourcesContent":["type Props = {\n  pushEvent: () => void;\n};\n\nexport function AddItemButton(props: Props) {\n  return (\n    <button\n      type=\"button\"\n      className=\"btn add-item-button\"\n      onClick={props.pushEvent}\n    >\n      <span>追加</span>\n    </button>\n  );\n}\n","import { ChangeEvent, useState } from \"react\";\nimport { ToMergeItem } from \"../feature/toMergeItem\";\n\ntype Props = {\n  id: string;\n  key: string;\n  manageItem: ToMergeItem;\n  deleteMyself: (key: string) => void;\n};\n\nexport function InputZone(props: Props) {\n  //フォームに入力されたときの関数。\n  function hundleEdit(event: ChangeEvent<HTMLInputElement>) {\n    //console.log(event.target.value);\n    props.manageItem.name = event.target.value;\n  }\n\n  const [exCount] = useState<number>(Math.floor(Math.random() * 10));\n\n  function returnEx(): string {\n    let str: string = \"!\";\n    for (let i = 0; i < exCount; i++) {\n      str += \"!\";\n    }\n\n    return str;\n  }\n\n  return (\n    <li>\n      <input\n        id={props.id}\n        type=\"text\"\n        className=\"input name-input\"\n        autoComplete=\"on\"\n        placeholder={\"概念を入力\" + returnEx()}\n        onChange={hundleEdit}\n      ></input>\n\n      <button\n        type=\"button\"\n        className=\"btn delete-button\"\n        onClick={() => props.deleteMyself(props.id)}\n      >\n        <span>削除</span>\n      </button>\n    </li>\n  );\n}\n","type Props = {\n  pushEvent: () => void;\n};\n\nexport function GotoSortButton(props: Props) {\n  return (\n    <button type=\"button\" className=\"btn sort-button\" onClick={props.pushEvent}>\n      <span>ソートする！</span>\n    </button>\n  );\n}\n","import { ToMergeItem } from \"../feature/toMergeItem\";\n\ntype Props = {\n  leftItem: ToMergeItem;\n  rightItem: ToMergeItem;\n  leftAction: () => void;\n  rightAction: () => void;\n};\n\n//ここにマージソートの選択する部分がある。\nexport function MergeSortSelect(props: Props) {\n  return (\n    <>\n      <button\n        type=\"button\"\n        className=\"btn left-select-button\"\n        onClick={() => props.leftAction()}\n      >\n        <span>{props.leftItem.name} が良い</span>\n      </button>\n      <button\n        type=\"button\"\n        className=\"btn right-select-button\"\n        onClick={() => props.rightAction()}\n      >\n        <span>{props.rightItem.name} が良い</span>\n      </button>\n    </>\n  );\n}\n","import { ToMergeItem } from \"../toMergeItem\";\nimport { MergeSortAction } from \"./mergeSortAction\";\nimport { MergeSortParameter } from \"./mergeSortPrameter\";\n\n//リデュース用？\n//ここにマージソートのアルゴリズムを書き込もう\nexport function mergeSort(\n  state: MergeSortParameter,\n  action: MergeSortAction\n): MergeSortParameter {\n  //最終的に代入する奴ら\n  let m_mergedItemList: ToMergeItem[] = [...state.mergedItemList];\n  let m_tempItemList: ToMergeItem[] = [...state.tempItemList];\n  let m_currentLeft: number = state.currentLeft;\n  let m_currentRight: number = state.currentRight;\n  let m_currentLeftEndPoint: number = state.currentLeftEndPoint;\n  let m_currentRightEndPoint: number = state.currentRightEndPoint;\n  let m_currentMergeCount: number = state.currentMergeCount;\n\n  switch (action.type) {\n    case \"LeftNext\": //左の選択がされたとき\n      selectLeft();\n      break;\n    case \"RightNext\": //右の選択がされたとき\n      selectRight();\n      break;\n    case \"Create\":\n      return action.initialize;\n    default:\n      break;\n  }\n\n  let returnParam: MergeSortParameter = {\n    mergedItemList: m_mergedItemList,\n    tempItemList: m_tempItemList,\n    currentLeft: m_currentLeft,\n    currentRight: m_currentRight,\n    currentLeftEndPoint: m_currentLeftEndPoint,\n    currentRightEndPoint: m_currentRightEndPoint,\n    currentMergeCount: m_currentMergeCount,\n  };\n\n  //console.log(returnParam);\n  //更新を掛ける\n  action.updateAction(\n    m_mergedItemList,\n    m_mergedItemList.length,\n    m_currentMergeCount\n  );\n\n  return returnParam;\n\n  function selectLeft() {\n    //console.log(\"左を選択\");\n    //えらばれしものを配列に入れる。\n    m_tempItemList = [...m_tempItemList, m_mergedItemList[m_currentLeft]];\n    //console.log(m_tempItemList);\n\n    //次の候補に移動\n    m_currentLeft += 1;\n\n    //限界になってしまったら、残った右の奴を順に配列に入れていく。\n    //その後、すべてのパラメータを更新する。\n    if (\n      m_currentLeft > m_currentLeftEndPoint ||\n      m_currentLeft >= m_mergedItemList.length\n    ) {\n      padAllRight();\n      updateSortPoint();\n    }\n  }\n\n  function selectRight() {\n    //console.log(\"右を選択\");\n    //えらばれしものを配列に入れる。\n    m_tempItemList = [...m_tempItemList, m_mergedItemList[m_currentRight]];\n    //次の候補に移動\n    m_currentRight += 1;\n\n    //限界になってしまったら、残った左の奴を順に配列に入れていく。\n    //その後、すべてのパラメータを更新する。\n    if (\n      m_currentRight > m_currentRightEndPoint ||\n      m_currentRight >= m_mergedItemList.length\n    ) {\n      padAllLeft();\n      updateSortPoint();\n    }\n  }\n\n  //左のものをすべて一時配列に詰める\n  function padAllLeft() {\n    //console.log(\"右全滅\");\n    while (\n      m_currentLeft <= m_currentLeftEndPoint &&\n      m_currentLeft < m_mergedItemList.length\n    ) {\n      m_tempItemList = [...m_tempItemList, m_mergedItemList[m_currentLeft]];\n      m_currentLeft += 1;\n    }\n  }\n  //右のものをすべて一時配列に詰める\n  function padAllRight() {\n    //console.log(\"左全滅\");\n    while (\n      m_currentRight <= m_currentRightEndPoint &&\n      m_currentRight < m_mergedItemList.length\n    ) {\n      m_tempItemList = [...m_tempItemList, m_mergedItemList[m_currentRight]];\n      m_currentRight += 1;\n    }\n  }\n\n  //次のソートポイントを確認する。\n  function updateSortPoint() {\n    //console.log(\"次の地点の確認\");\n    //次の左右の終着点\n    m_currentLeftEndPoint =\n      m_currentLeftEndPoint + Math.pow(2, m_currentMergeCount + 1);\n    m_currentRightEndPoint =\n      m_currentRightEndPoint + Math.pow(2, m_currentMergeCount + 1);\n\n    //次の左右の始点\n    m_currentLeft =\n      m_currentLeftEndPoint - Math.pow(2, m_currentMergeCount) + 1;\n    m_currentRight =\n      m_currentRightEndPoint - Math.pow(2, m_currentMergeCount) + 1;\n\n    //以下、例外条件を潰していく。\n    if (m_currentRight >= m_mergedItemList.length) {\n      //console.log(\"時点の右始点は配列外\" + m_currentRight);\n      //右の始点がそもそも配列外の時は、もう自動的に左の物を配列に入れてあげる。(左がない場合もある。)\n      padAllLeft();\n      //ここで1段階目のマージが完了\n      //マージ回数を増やし、その回数目での初期位置にする。\n      m_currentMergeCount = m_currentMergeCount + 1;\n      m_currentLeftEndPoint = Math.pow(2, m_currentMergeCount) - 1;\n      m_currentRightEndPoint = Math.pow(2, m_currentMergeCount + 1) - 1;\n      m_currentLeft =\n        m_currentLeftEndPoint - (Math.pow(2, m_currentMergeCount) - 1); //つまり0です。\n      m_currentRight =\n        m_currentRightEndPoint - (Math.pow(2, m_currentMergeCount) - 1); //つまり2^currentMergeCountです。\n      //さらに、マージしたリストを更新する\n      m_mergedItemList = [...m_tempItemList];\n      //一時リストは空にする。\n      m_tempItemList = [];\n    }\n  }\n}\n","type Props = {\n  ranking: number;\n  itemName: string;\n};\n\nexport function ResultText(props: Props) {\n  return (\n    <p className=\"txt result-text\">\n      {props.ranking}番目に好きなのは{props.itemName}です。\n    </p>\n  );\n}\n","export function message() {\n  // 最初にコメントを入れよう！！\n  console.group(\"開発者メッセージ\");\n  const style1 = `font-size: 24px;\n  font-family: serif;\n  font-weight: bold;\n   color: #6e0202;\n   background: #db722c;`;\n  const style2 = `font-size: 14px;\n   font-family: serif;\n   font-weight: bold;\n    color: #F3A696;\n   background: #520d2e;`;\n  const style3 = `font-size: 16px;\n   font-family: serif;\n    color: #d4fff5;\n   background: #0d3d52;`;\n  console.warn(\"はずかしいやん\");\n  console.log(\n    `\n%c    ゆっくりマージソートしていってね！\n%c  それは儚きあなたの思いを無残にも具現化してしまうアルゴリズム……\n%c                     そして貴方はGitHubへと誘われる…… \n\nhttps://github.com/RKyo65535/MergeSortingWebApp\n`,\n    style1,\n    style2,\n    style3\n  );\n  console.groupEnd();\n}\n","import { useEffect, useReducer, useState } from \"react\";\nimport { AddItemButton } from \"./components/AddItemButton\";\nimport { InputZone } from \"./components/InputZone\";\nimport { ToMergeItem } from \"./feature/toMergeItem\";\nimport { nanoid } from \"nanoid\";\nimport { ViewPhase } from \"./feature/viewPhase\";\nimport { GotoSortButton } from \"./components/GotoSortButton\";\nimport { MergeSortSelect } from \"./components/MergeSortSelect\";\nimport { mergeSort } from \"./feature/mergeSort/mergeSort\";\nimport { MergeSortParameter } from \"./feature/mergeSort/mergeSortPrameter\";\nimport { MergeSortAction } from \"./feature/mergeSort/mergeSortAction\";\nimport { ResultText } from \"./components/ResultText\";\nimport { message } from \"./sandbox/message\";\n\nexport function App() {\n  //最初に遊びごごろを。謎メッセージを出す。\n  //一回だけ出す\n  useEffect(message, []);\n\n  //ここで全体を管理します。\n\n  //現在のフェーズ(状態)\n  const [phase, setPhase] = useState<ViewPhase>(\"Set\");\n\n  //デフォルトリスト\n  const defaultItems: ToMergeItem[] = [\n    { id: nanoid(), name: \"選択肢1\" },\n    { id: nanoid(), name: \"選択肢2\" },\n    { id: nanoid(), name: \"選択肢3\" },\n    { id: nanoid(), name: \"選択肢4\" },\n    { id: nanoid(), name: \"選択肢5\" },\n    { id: nanoid(), name: \"選択肢6\" },\n    { id: nanoid(), name: \"選択肢7\" },\n    { id: nanoid(), name: \"選択肢8\" },\n  ];\n  //現在のリスト\n  const [currentItemList, setCurrentItemList] =\n    useState<ToMergeItem[]>(defaultItems);\n\n  //マージソートの最初の状態？\n  const initialState: MergeSortParameter = {\n    mergedItemList: [],\n    tempItemList: [],\n    currentLeft: 0,\n    currentRight: 0,\n    currentLeftEndPoint: 0,\n    currentRightEndPoint: 0,\n    currentMergeCount: 0,\n  };\n\n  //これを通じてマージソートの状態を扱う\n  const [mergeState, dispatchMergeState] = useReducer(mergeSort, initialState);\n\n  //アイテム追加用の関数。\n  function addItem() {\n    const newItem: ToMergeItem = {\n      id: \"id\" + nanoid(),\n      name: \"\",\n    };\n    setCurrentItemList([...currentItemList, newItem]);\n  }\n  //要素が追加されたら、下スクロールする\n  useEffect(() => window.scrollBy(0, 100), [currentItemList]);\n\n  function deleteItem(key: string) {\n    //自身以外をリストに残す形で、自信を滅する\n    const remainingItems = currentItemList.filter((item) => key !== item.id);\n    setCurrentItemList(remainingItems);\n  }\n\n  //現在の表示状態を変更する\n  function changeState(phase: ViewPhase) {\n    setPhase(phase);\n  }\n\n  //マージソート開始のお知らせ\n  function startMergeSort() {\n    if (currentItemList.length >= 2) {\n      changeState(\"Sort\");\n      initMergeSort();\n    }\n  }\n\n  //マージソート情報の初期化\n  function initMergeSort() {\n    const tempList: ToMergeItem[] = [...currentItemList];\n    const mergeAction: MergeSortAction = {\n      type: \"Create\",\n      initialize: {\n        //とりあえず複数の段階でマージ完了したリスト\n        mergedItemList: tempList,\n        //マージ途中のリスト\n        tempItemList: [],\n        //マージする幅の左右の着目点\n        currentLeft: 0,\n        currentRight: 1,\n        //マージする左右の終着点\n        currentLeftEndPoint: 0,\n        currentRightEndPoint: 1,\n        //2^これ 個のブロックを処理するという変数\n        currentMergeCount: 0,\n      },\n      updateAction: chackMergeCondition,\n    };\n    dispatchMergeState(mergeAction);\n  }\n\n  //マージソートで左を選択\n  function selectLeft() {\n    const mergeAction: MergeSortAction = {\n      type: \"LeftNext\",\n      initialize: initialState,\n      updateAction: chackMergeCondition,\n    };\n    dispatchMergeState(mergeAction);\n  }\n\n  //マージソートで右を選択。\n  function selectRight() {\n    const mergeAction: MergeSortAction = {\n      type: \"RightNext\",\n      initialize: initialState,\n      updateAction: chackMergeCondition,\n    };\n    dispatchMergeState(mergeAction);\n  }\n\n  //マージの状態によって、現在の状態を変化させる\n  function chackMergeCondition(\n    list: ToMergeItem[],\n    itemLength: number,\n    currentMergeCount: number\n  ) {\n    //ソートの必要が無くなったらこれを実行\n    if (itemLength <= Math.pow(2, currentMergeCount)) {\n      //console.log(\"モード変更！\");\n      setPhase(\"Result\");\n    }\n    //現在のリストに反映\n    setCurrentItemList([...list]);\n  }\n\n  //ここから下は表示内容を変化させる。\n  //現在のリストを、良い感じに実態(View?)に渡してやる\n  //入力フォームを複製できるのだ\n  let currentShowItemList: JSX.Element[] = [];\n  let beforeMergeSortElement: JSX.Element[] = [];\n\n  if (phase === \"Set\") {\n    currentShowItemList = currentItemList.map((item) => (\n      <InputZone\n        id={item.id}\n        key={item.id}\n        manageItem={item}\n        deleteMyself={deleteItem}\n      />\n    ));\n    beforeMergeSortElement = [\n      <AddItemButton pushEvent={addItem} key={nanoid()} />,\n      <GotoSortButton pushEvent={startMergeSort} key={nanoid()} />,\n    ];\n  }\n\n  let mergeSortZone: JSX.Element = <></>;\n\n  if (phase === \"Sort\") {\n    mergeSortZone = (\n      <MergeSortSelect\n        leftItem={currentItemList[mergeState.currentLeft]}\n        rightItem={currentItemList[mergeState.currentRight]}\n        leftAction={selectLeft}\n        rightAction={selectRight}\n      />\n    );\n  }\n\n  let resultZone: JSX.Element = <></>;\n  let sortResult: JSX.Element[] = [];\n  if (phase === \"Result\") {\n    resultZone = <>マージ完了</>;\n\n    for (let i = 0; i < currentItemList.length; i++) {\n      let oneResult: JSX.Element = (\n        <ResultText\n          ranking={i + 1}\n          itemName={currentItemList[i].name}\n          key={nanoid()}\n        />\n      );\n      sortResult = [...sortResult, oneResult];\n    }\n  }\n\n  //ここから下がメイン部分\n  return (\n    <div className=\"margeAll\">\n      <h1 className=\"title\">マージソートアプリ</h1>\n\n      {currentShowItemList}\n      {beforeMergeSortElement}\n\n      {mergeSortZone}\n      {resultZone}\n      {sortResult}\n    </div>\n  );\n}\n","import { StrictMode } from \"react\";\nimport ReactDOM from \"react-dom\";\nimport { App } from \"./App\";\nimport \"./css/style.css\";\n\n//rootタグのついた場所にReactでつくったものを入れるのだ\nReactDOM.render(\n  <StrictMode>\n    <App />\n  </StrictMode>,\n  document.getElementById(\"root\")\n);\n"],"sourceRoot":""}